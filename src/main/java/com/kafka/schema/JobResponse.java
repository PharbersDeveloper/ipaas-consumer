/**
 * Autogenerated by Avro
 *
 * DO NOT EDIT DIRECTLY
 */
package com.kafka.schema;

import org.apache.avro.specific.SpecificData;

@SuppressWarnings("all")
@org.apache.avro.specific.AvroGenerated
public class JobResponse extends org.apache.avro.specific.SpecificRecordBase implements org.apache.avro.specific.SpecificRecord {
  private static final long serialVersionUID = 6858396730033153712L;
  public static final org.apache.avro.Schema SCHEMA$ = new org.apache.avro.Schema.Parser().parse("{\"type\":\"record\",\"name\":\"JobResponse\",\"namespace\":\"com.kafka.schema\",\"fields\":[{\"name\":\"jobType\",\"type\":\"string\"},{\"name\":\"master\",\"type\":\"string\"},{\"name\":\"deployMode\",\"type\":\"string\"},{\"name\":\"driverMemory\",\"type\":\"string\"},{\"name\":\"executorMemory\",\"type\":\"string\"},{\"name\":\"executorCores\",\"type\":\"string\"},{\"name\":\"queue\",\"type\":\"string\"},{\"name\":\"target\",\"type\":\"string\"},{\"name\":\"config\",\"type\":\"string\"}]}");
  public static org.apache.avro.Schema getClassSchema() { return SCHEMA$; }
  @Deprecated public java.lang.CharSequence jobType;
  @Deprecated public java.lang.CharSequence master;
  @Deprecated public java.lang.CharSequence deployMode;
  @Deprecated public java.lang.CharSequence driverMemory;
  @Deprecated public java.lang.CharSequence executorMemory;
  @Deprecated public java.lang.CharSequence executorCores;
  @Deprecated public java.lang.CharSequence queue;
  @Deprecated public java.lang.CharSequence target;
  @Deprecated public java.lang.CharSequence config;

  /**
   * Default constructor.  Note that this does not initialize fields
   * to their default values from the schema.  If that is desired then
   * one should use <code>newBuilder()</code>.
   */
  public JobResponse() {}

  /**
   * All-args constructor.
   * @param jobType The new value for jobType
   * @param master The new value for master
   * @param deployMode The new value for deployMode
   * @param driverMemory The new value for driverMemory
   * @param executorMemory The new value for executorMemory
   * @param executorCores The new value for executorCores
   * @param queue The new value for queue
   * @param target The new value for target
   * @param config The new value for config
   */
  public JobResponse(java.lang.CharSequence jobType, java.lang.CharSequence master, java.lang.CharSequence deployMode, java.lang.CharSequence driverMemory, java.lang.CharSequence executorMemory, java.lang.CharSequence executorCores, java.lang.CharSequence queue, java.lang.CharSequence target, java.lang.CharSequence config) {
    this.jobType = jobType;
    this.master = master;
    this.deployMode = deployMode;
    this.driverMemory = driverMemory;
    this.executorMemory = executorMemory;
    this.executorCores = executorCores;
    this.queue = queue;
    this.target = target;
    this.config = config;
  }

  public org.apache.avro.Schema getSchema() { return SCHEMA$; }
  // Used by DatumWriter.  Applications should not call.
  public java.lang.Object get(int field$) {
    switch (field$) {
    case 0: return jobType;
    case 1: return master;
    case 2: return deployMode;
    case 3: return driverMemory;
    case 4: return executorMemory;
    case 5: return executorCores;
    case 6: return queue;
    case 7: return target;
    case 8: return config;
    default: throw new org.apache.avro.AvroRuntimeException("Bad index");
    }
  }

  // Used by DatumReader.  Applications should not call.
  @SuppressWarnings(value="unchecked")
  public void put(int field$, java.lang.Object value$) {
    switch (field$) {
    case 0: jobType = (java.lang.CharSequence)value$; break;
    case 1: master = (java.lang.CharSequence)value$; break;
    case 2: deployMode = (java.lang.CharSequence)value$; break;
    case 3: driverMemory = (java.lang.CharSequence)value$; break;
    case 4: executorMemory = (java.lang.CharSequence)value$; break;
    case 5: executorCores = (java.lang.CharSequence)value$; break;
    case 6: queue = (java.lang.CharSequence)value$; break;
    case 7: target = (java.lang.CharSequence)value$; break;
    case 8: config = (java.lang.CharSequence)value$; break;
    default: throw new org.apache.avro.AvroRuntimeException("Bad index");
    }
  }

  /**
   * Gets the value of the 'jobType' field.
   * @return The value of the 'jobType' field.
   */
  public java.lang.CharSequence getJobType() {
    return jobType;
  }

  /**
   * Sets the value of the 'jobType' field.
   * @param value the value to set.
   */
  public void setJobType(java.lang.CharSequence value) {
    this.jobType = value;
  }

  /**
   * Gets the value of the 'master' field.
   * @return The value of the 'master' field.
   */
  public java.lang.CharSequence getMaster() {
    return master;
  }

  /**
   * Sets the value of the 'master' field.
   * @param value the value to set.
   */
  public void setMaster(java.lang.CharSequence value) {
    this.master = value;
  }

  /**
   * Gets the value of the 'deployMode' field.
   * @return The value of the 'deployMode' field.
   */
  public java.lang.CharSequence getDeployMode() {
    return deployMode;
  }

  /**
   * Sets the value of the 'deployMode' field.
   * @param value the value to set.
   */
  public void setDeployMode(java.lang.CharSequence value) {
    this.deployMode = value;
  }

  /**
   * Gets the value of the 'driverMemory' field.
   * @return The value of the 'driverMemory' field.
   */
  public java.lang.CharSequence getDriverMemory() {
    return driverMemory;
  }

  /**
   * Sets the value of the 'driverMemory' field.
   * @param value the value to set.
   */
  public void setDriverMemory(java.lang.CharSequence value) {
    this.driverMemory = value;
  }

  /**
   * Gets the value of the 'executorMemory' field.
   * @return The value of the 'executorMemory' field.
   */
  public java.lang.CharSequence getExecutorMemory() {
    return executorMemory;
  }

  /**
   * Sets the value of the 'executorMemory' field.
   * @param value the value to set.
   */
  public void setExecutorMemory(java.lang.CharSequence value) {
    this.executorMemory = value;
  }

  /**
   * Gets the value of the 'executorCores' field.
   * @return The value of the 'executorCores' field.
   */
  public java.lang.CharSequence getExecutorCores() {
    return executorCores;
  }

  /**
   * Sets the value of the 'executorCores' field.
   * @param value the value to set.
   */
  public void setExecutorCores(java.lang.CharSequence value) {
    this.executorCores = value;
  }

  /**
   * Gets the value of the 'queue' field.
   * @return The value of the 'queue' field.
   */
  public java.lang.CharSequence getQueue() {
    return queue;
  }

  /**
   * Sets the value of the 'queue' field.
   * @param value the value to set.
   */
  public void setQueue(java.lang.CharSequence value) {
    this.queue = value;
  }

  /**
   * Gets the value of the 'target' field.
   * @return The value of the 'target' field.
   */
  public java.lang.CharSequence getTarget() {
    return target;
  }

  /**
   * Sets the value of the 'target' field.
   * @param value the value to set.
   */
  public void setTarget(java.lang.CharSequence value) {
    this.target = value;
  }

  /**
   * Gets the value of the 'config' field.
   * @return The value of the 'config' field.
   */
  public java.lang.CharSequence getConfig() {
    return config;
  }

  /**
   * Sets the value of the 'config' field.
   * @param value the value to set.
   */
  public void setConfig(java.lang.CharSequence value) {
    this.config = value;
  }

  /**
   * Creates a new JobResponse RecordBuilder.
   * @return A new JobResponse RecordBuilder
   */
  public static com.kafka.schema.JobResponse.Builder newBuilder() {
    return new com.kafka.schema.JobResponse.Builder();
  }

  /**
   * Creates a new JobResponse RecordBuilder by copying an existing Builder.
   * @param other The existing builder to copy.
   * @return A new JobResponse RecordBuilder
   */
  public static com.kafka.schema.JobResponse.Builder newBuilder(com.kafka.schema.JobResponse.Builder other) {
    return new com.kafka.schema.JobResponse.Builder(other);
  }

  /**
   * Creates a new JobResponse RecordBuilder by copying an existing JobResponse instance.
   * @param other The existing instance to copy.
   * @return A new JobResponse RecordBuilder
   */
  public static com.kafka.schema.JobResponse.Builder newBuilder(com.kafka.schema.JobResponse other) {
    return new com.kafka.schema.JobResponse.Builder(other);
  }

  /**
   * RecordBuilder for JobResponse instances.
   */
  public static class Builder extends org.apache.avro.specific.SpecificRecordBuilderBase<JobResponse>
    implements org.apache.avro.data.RecordBuilder<JobResponse> {

    private java.lang.CharSequence jobType;
    private java.lang.CharSequence master;
    private java.lang.CharSequence deployMode;
    private java.lang.CharSequence driverMemory;
    private java.lang.CharSequence executorMemory;
    private java.lang.CharSequence executorCores;
    private java.lang.CharSequence queue;
    private java.lang.CharSequence target;
    private java.lang.CharSequence config;

    /** Creates a new Builder */
    private Builder() {
      super(SCHEMA$);
    }

    /**
     * Creates a Builder by copying an existing Builder.
     * @param other The existing Builder to copy.
     */
    private Builder(com.kafka.schema.JobResponse.Builder other) {
      super(other);
      if (isValidValue(fields()[0], other.jobType)) {
        this.jobType = data().deepCopy(fields()[0].schema(), other.jobType);
        fieldSetFlags()[0] = true;
      }
      if (isValidValue(fields()[1], other.master)) {
        this.master = data().deepCopy(fields()[1].schema(), other.master);
        fieldSetFlags()[1] = true;
      }
      if (isValidValue(fields()[2], other.deployMode)) {
        this.deployMode = data().deepCopy(fields()[2].schema(), other.deployMode);
        fieldSetFlags()[2] = true;
      }
      if (isValidValue(fields()[3], other.driverMemory)) {
        this.driverMemory = data().deepCopy(fields()[3].schema(), other.driverMemory);
        fieldSetFlags()[3] = true;
      }
      if (isValidValue(fields()[4], other.executorMemory)) {
        this.executorMemory = data().deepCopy(fields()[4].schema(), other.executorMemory);
        fieldSetFlags()[4] = true;
      }
      if (isValidValue(fields()[5], other.executorCores)) {
        this.executorCores = data().deepCopy(fields()[5].schema(), other.executorCores);
        fieldSetFlags()[5] = true;
      }
      if (isValidValue(fields()[6], other.queue)) {
        this.queue = data().deepCopy(fields()[6].schema(), other.queue);
        fieldSetFlags()[6] = true;
      }
      if (isValidValue(fields()[7], other.target)) {
        this.target = data().deepCopy(fields()[7].schema(), other.target);
        fieldSetFlags()[7] = true;
      }
      if (isValidValue(fields()[8], other.config)) {
        this.config = data().deepCopy(fields()[8].schema(), other.config);
        fieldSetFlags()[8] = true;
      }
    }

    /**
     * Creates a Builder by copying an existing JobResponse instance
     * @param other The existing instance to copy.
     */
    private Builder(com.kafka.schema.JobResponse other) {
            super(SCHEMA$);
      if (isValidValue(fields()[0], other.jobType)) {
        this.jobType = data().deepCopy(fields()[0].schema(), other.jobType);
        fieldSetFlags()[0] = true;
      }
      if (isValidValue(fields()[1], other.master)) {
        this.master = data().deepCopy(fields()[1].schema(), other.master);
        fieldSetFlags()[1] = true;
      }
      if (isValidValue(fields()[2], other.deployMode)) {
        this.deployMode = data().deepCopy(fields()[2].schema(), other.deployMode);
        fieldSetFlags()[2] = true;
      }
      if (isValidValue(fields()[3], other.driverMemory)) {
        this.driverMemory = data().deepCopy(fields()[3].schema(), other.driverMemory);
        fieldSetFlags()[3] = true;
      }
      if (isValidValue(fields()[4], other.executorMemory)) {
        this.executorMemory = data().deepCopy(fields()[4].schema(), other.executorMemory);
        fieldSetFlags()[4] = true;
      }
      if (isValidValue(fields()[5], other.executorCores)) {
        this.executorCores = data().deepCopy(fields()[5].schema(), other.executorCores);
        fieldSetFlags()[5] = true;
      }
      if (isValidValue(fields()[6], other.queue)) {
        this.queue = data().deepCopy(fields()[6].schema(), other.queue);
        fieldSetFlags()[6] = true;
      }
      if (isValidValue(fields()[7], other.target)) {
        this.target = data().deepCopy(fields()[7].schema(), other.target);
        fieldSetFlags()[7] = true;
      }
      if (isValidValue(fields()[8], other.config)) {
        this.config = data().deepCopy(fields()[8].schema(), other.config);
        fieldSetFlags()[8] = true;
      }
    }

    /**
      * Gets the value of the 'jobType' field.
      * @return The value.
      */
    public java.lang.CharSequence getJobType() {
      return jobType;
    }

    /**
      * Sets the value of the 'jobType' field.
      * @param value The value of 'jobType'.
      * @return This builder.
      */
    public com.kafka.schema.JobResponse.Builder setJobType(java.lang.CharSequence value) {
      validate(fields()[0], value);
      this.jobType = value;
      fieldSetFlags()[0] = true;
      return this;
    }

    /**
      * Checks whether the 'jobType' field has been set.
      * @return True if the 'jobType' field has been set, false otherwise.
      */
    public boolean hasJobType() {
      return fieldSetFlags()[0];
    }


    /**
      * Clears the value of the 'jobType' field.
      * @return This builder.
      */
    public com.kafka.schema.JobResponse.Builder clearJobType() {
      jobType = null;
      fieldSetFlags()[0] = false;
      return this;
    }

    /**
      * Gets the value of the 'master' field.
      * @return The value.
      */
    public java.lang.CharSequence getMaster() {
      return master;
    }

    /**
      * Sets the value of the 'master' field.
      * @param value The value of 'master'.
      * @return This builder.
      */
    public com.kafka.schema.JobResponse.Builder setMaster(java.lang.CharSequence value) {
      validate(fields()[1], value);
      this.master = value;
      fieldSetFlags()[1] = true;
      return this;
    }

    /**
      * Checks whether the 'master' field has been set.
      * @return True if the 'master' field has been set, false otherwise.
      */
    public boolean hasMaster() {
      return fieldSetFlags()[1];
    }


    /**
      * Clears the value of the 'master' field.
      * @return This builder.
      */
    public com.kafka.schema.JobResponse.Builder clearMaster() {
      master = null;
      fieldSetFlags()[1] = false;
      return this;
    }

    /**
      * Gets the value of the 'deployMode' field.
      * @return The value.
      */
    public java.lang.CharSequence getDeployMode() {
      return deployMode;
    }

    /**
      * Sets the value of the 'deployMode' field.
      * @param value The value of 'deployMode'.
      * @return This builder.
      */
    public com.kafka.schema.JobResponse.Builder setDeployMode(java.lang.CharSequence value) {
      validate(fields()[2], value);
      this.deployMode = value;
      fieldSetFlags()[2] = true;
      return this;
    }

    /**
      * Checks whether the 'deployMode' field has been set.
      * @return True if the 'deployMode' field has been set, false otherwise.
      */
    public boolean hasDeployMode() {
      return fieldSetFlags()[2];
    }


    /**
      * Clears the value of the 'deployMode' field.
      * @return This builder.
      */
    public com.kafka.schema.JobResponse.Builder clearDeployMode() {
      deployMode = null;
      fieldSetFlags()[2] = false;
      return this;
    }

    /**
      * Gets the value of the 'driverMemory' field.
      * @return The value.
      */
    public java.lang.CharSequence getDriverMemory() {
      return driverMemory;
    }

    /**
      * Sets the value of the 'driverMemory' field.
      * @param value The value of 'driverMemory'.
      * @return This builder.
      */
    public com.kafka.schema.JobResponse.Builder setDriverMemory(java.lang.CharSequence value) {
      validate(fields()[3], value);
      this.driverMemory = value;
      fieldSetFlags()[3] = true;
      return this;
    }

    /**
      * Checks whether the 'driverMemory' field has been set.
      * @return True if the 'driverMemory' field has been set, false otherwise.
      */
    public boolean hasDriverMemory() {
      return fieldSetFlags()[3];
    }


    /**
      * Clears the value of the 'driverMemory' field.
      * @return This builder.
      */
    public com.kafka.schema.JobResponse.Builder clearDriverMemory() {
      driverMemory = null;
      fieldSetFlags()[3] = false;
      return this;
    }

    /**
      * Gets the value of the 'executorMemory' field.
      * @return The value.
      */
    public java.lang.CharSequence getExecutorMemory() {
      return executorMemory;
    }

    /**
      * Sets the value of the 'executorMemory' field.
      * @param value The value of 'executorMemory'.
      * @return This builder.
      */
    public com.kafka.schema.JobResponse.Builder setExecutorMemory(java.lang.CharSequence value) {
      validate(fields()[4], value);
      this.executorMemory = value;
      fieldSetFlags()[4] = true;
      return this;
    }

    /**
      * Checks whether the 'executorMemory' field has been set.
      * @return True if the 'executorMemory' field has been set, false otherwise.
      */
    public boolean hasExecutorMemory() {
      return fieldSetFlags()[4];
    }


    /**
      * Clears the value of the 'executorMemory' field.
      * @return This builder.
      */
    public com.kafka.schema.JobResponse.Builder clearExecutorMemory() {
      executorMemory = null;
      fieldSetFlags()[4] = false;
      return this;
    }

    /**
      * Gets the value of the 'executorCores' field.
      * @return The value.
      */
    public java.lang.CharSequence getExecutorCores() {
      return executorCores;
    }

    /**
      * Sets the value of the 'executorCores' field.
      * @param value The value of 'executorCores'.
      * @return This builder.
      */
    public com.kafka.schema.JobResponse.Builder setExecutorCores(java.lang.CharSequence value) {
      validate(fields()[5], value);
      this.executorCores = value;
      fieldSetFlags()[5] = true;
      return this;
    }

    /**
      * Checks whether the 'executorCores' field has been set.
      * @return True if the 'executorCores' field has been set, false otherwise.
      */
    public boolean hasExecutorCores() {
      return fieldSetFlags()[5];
    }


    /**
      * Clears the value of the 'executorCores' field.
      * @return This builder.
      */
    public com.kafka.schema.JobResponse.Builder clearExecutorCores() {
      executorCores = null;
      fieldSetFlags()[5] = false;
      return this;
    }

    /**
      * Gets the value of the 'queue' field.
      * @return The value.
      */
    public java.lang.CharSequence getQueue() {
      return queue;
    }

    /**
      * Sets the value of the 'queue' field.
      * @param value The value of 'queue'.
      * @return This builder.
      */
    public com.kafka.schema.JobResponse.Builder setQueue(java.lang.CharSequence value) {
      validate(fields()[6], value);
      this.queue = value;
      fieldSetFlags()[6] = true;
      return this;
    }

    /**
      * Checks whether the 'queue' field has been set.
      * @return True if the 'queue' field has been set, false otherwise.
      */
    public boolean hasQueue() {
      return fieldSetFlags()[6];
    }


    /**
      * Clears the value of the 'queue' field.
      * @return This builder.
      */
    public com.kafka.schema.JobResponse.Builder clearQueue() {
      queue = null;
      fieldSetFlags()[6] = false;
      return this;
    }

    /**
      * Gets the value of the 'target' field.
      * @return The value.
      */
    public java.lang.CharSequence getTarget() {
      return target;
    }

    /**
      * Sets the value of the 'target' field.
      * @param value The value of 'target'.
      * @return This builder.
      */
    public com.kafka.schema.JobResponse.Builder setTarget(java.lang.CharSequence value) {
      validate(fields()[7], value);
      this.target = value;
      fieldSetFlags()[7] = true;
      return this;
    }

    /**
      * Checks whether the 'target' field has been set.
      * @return True if the 'target' field has been set, false otherwise.
      */
    public boolean hasTarget() {
      return fieldSetFlags()[7];
    }


    /**
      * Clears the value of the 'target' field.
      * @return This builder.
      */
    public com.kafka.schema.JobResponse.Builder clearTarget() {
      target = null;
      fieldSetFlags()[7] = false;
      return this;
    }

    /**
      * Gets the value of the 'config' field.
      * @return The value.
      */
    public java.lang.CharSequence getConfig() {
      return config;
    }

    /**
      * Sets the value of the 'config' field.
      * @param value The value of 'config'.
      * @return This builder.
      */
    public com.kafka.schema.JobResponse.Builder setConfig(java.lang.CharSequence value) {
      validate(fields()[8], value);
      this.config = value;
      fieldSetFlags()[8] = true;
      return this;
    }

    /**
      * Checks whether the 'config' field has been set.
      * @return True if the 'config' field has been set, false otherwise.
      */
    public boolean hasConfig() {
      return fieldSetFlags()[8];
    }


    /**
      * Clears the value of the 'config' field.
      * @return This builder.
      */
    public com.kafka.schema.JobResponse.Builder clearConfig() {
      config = null;
      fieldSetFlags()[8] = false;
      return this;
    }

    @Override
    public JobResponse build() {
      try {
        JobResponse record = new JobResponse();
        record.jobType = fieldSetFlags()[0] ? this.jobType : (java.lang.CharSequence) defaultValue(fields()[0]);
        record.master = fieldSetFlags()[1] ? this.master : (java.lang.CharSequence) defaultValue(fields()[1]);
        record.deployMode = fieldSetFlags()[2] ? this.deployMode : (java.lang.CharSequence) defaultValue(fields()[2]);
        record.driverMemory = fieldSetFlags()[3] ? this.driverMemory : (java.lang.CharSequence) defaultValue(fields()[3]);
        record.executorMemory = fieldSetFlags()[4] ? this.executorMemory : (java.lang.CharSequence) defaultValue(fields()[4]);
        record.executorCores = fieldSetFlags()[5] ? this.executorCores : (java.lang.CharSequence) defaultValue(fields()[5]);
        record.queue = fieldSetFlags()[6] ? this.queue : (java.lang.CharSequence) defaultValue(fields()[6]);
        record.target = fieldSetFlags()[7] ? this.target : (java.lang.CharSequence) defaultValue(fields()[7]);
        record.config = fieldSetFlags()[8] ? this.config : (java.lang.CharSequence) defaultValue(fields()[8]);
        return record;
      } catch (Exception e) {
        throw new org.apache.avro.AvroRuntimeException(e);
      }
    }
  }

  private static final org.apache.avro.io.DatumWriter
    WRITER$ = new org.apache.avro.specific.SpecificDatumWriter(SCHEMA$);

  @Override public void writeExternal(java.io.ObjectOutput out)
    throws java.io.IOException {
    WRITER$.write(this, SpecificData.getEncoder(out));
  }

  private static final org.apache.avro.io.DatumReader
    READER$ = new org.apache.avro.specific.SpecificDatumReader(SCHEMA$);

  @Override public void readExternal(java.io.ObjectInput in)
    throws java.io.IOException {
    READER$.read(this, SpecificData.getDecoder(in));
  }

}
